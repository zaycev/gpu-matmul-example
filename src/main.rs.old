use std::arch::aarch64::*; // Use ARM neon intrinsics.
const N: usize = 4;
type Matrix = [[f32; N]; N];
// Row-major order.
const test_a: Matrix = [[1.0,  2.0,  3.0,  4.0 ],
                        [5.0,  6.0,  7.0,  8.0 ],
                        [9.0,  10.0, 11.0, 12.0],
                        [13.0, 14.0, 15.0, 16.0]];
// Column-major order.
const test_b: Matrix = [[1.0,  5.0,  9.0,  13.0],
                        [2.0,  6.0,  10.0, 14.0],
                        [3.0,  7.0,  11.0, 15.0],
                        [4.0,  8.0,  12.0, 16.0]];

fn multiple_simd(a: &Matrix, b: &Matrix, c: &mut Matrix) {
    unsafe {
        for i in 0..N {
            // Load a row-vector from A.
            let a_v = vld1q_f32(&a[i][0]);

            for j in 0..N {
                // Load a column-vector from B.
                let b_v = vld1q_f32(&b[j][0]);
                // Multiply.
                let r_v = vmulq_f32(a_v, b_v);
                let mut r = [0.0; 4];
                // Store the result.
                vst1q_f32(&mut r[0], r_v);
                // Update the result.
                c[i][j] = r.iter().sum::<f32>();
            }
        }
    }
}

fn main() {
    let mut c = [[0.0; N]; N];
    multiple_simd(&test_a, &test_b, &mut c);
    for row in &c {
        println!("{:?}", row);
    }
}
